---           
layout: post
title: Maven + hibernate + jpa + ehcache + spring + terracotta + composite keys
date: 2008-12-17 13:44:06 UTC
updated: 2008-12-17 13:44:06 UTC
comments: false
categories: 
---
 
Some user were having some <a href="http://forums.terracotta.org/forums/posts/list/1579.page">problem</a> using composite keys with hibernate and ehcache as second level cache with Terracotta.<br /><br />I tried beefing up a sample app with composite keys so that I can run the app with Terracotta...  and it worked out smoothly in a quite small amount of time.<br /><br />I reused much of what we did for <a href="http://reference.terracotta.org/">Examinator</a>, and came up with the app without much pain in very small amount of time. Really, <a href="http://www.terracotta.org/web/display/orgsite/Web+App+Reference+Implementation">Examinator</a> (<a href="http://svn.terracotta.org/repo/forge/projects/exam/trunk/">source</a>) contains quite a lot of things that can be re-used to come up with with these kind of apps.<br /><br />I'll try to put in the main parts of the sample app that I came up here:<br /><br />Used maven-quickstart archetype to generate a quick project skeleton.<br /><br />First the domain classes -- Its a Product class, which is uniquely identified by a combination of its productId and groupId. It also has a description property.<br /><pre name="code" class="java:collapse"><br />package sample.model;<br /><br />import javax.persistence.Column;<br />import javax.persistence.Entity;<br />import javax.persistence.Id;<br />import javax.persistence.IdClass;<br /><br />import org.hibernate.annotations.Cache;<br />import org.hibernate.annotations.CacheConcurrencyStrategy;<br /><br />@Entity<br />@IdClass(ProductCompositeKey.class)<br />@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)<br />public class Product {<br /><br />@Id<br />private Long productId;<br /><br />@Id<br />private Long groupId;<br /><br />@Column(name = "DESCRIPTION")<br />private String description;<br /><br />//...getters and setters...<br /><br />}<br /><br /></pre><br /><br />We are using JPA annotations to define the entities. We annotate the Product class with the @Entity annotation, and as normally, annotate the productId and groupId properties with @Id.<br />We are using hibernate annotation @Cache(usage = CacheConcurrencyStrategy.READ_WRITE) to enable second-level caching on this entity.<br />The @IdClass annotation refers to a class which will be the composite-key class.<br />The ProductCompositeKey is this class and is as follows:<br /><pre name="code" class="java:collapse"><br />package sample.model;<br /><br />import java.io.Serializable;<br /><br />import javax.persistence.Embeddable;<br /><br />@Embeddable<br />public class ProductCompositeKey implements Serializable {<br /><br />private Long productId;<br />private Long groupId;<br /><br />//...getters and setters...<br /><br />@Override<br />public int hashCode() {<br />final int prime = 31;<br />int result = 1;<br />result = prime * result + ((groupId == null) ? 0 : groupId.hashCode());<br />result = prime * result + ((productId == null) ? 0 : productId.hashCode());<br />return result;<br />}<br /><br />@Override<br />public boolean equals(Object obj) {<br />if (this == obj)<br />return true;<br />if (obj == null)<br />return false;<br />if (getClass() != obj.getClass())<br />return false;<br />ProductCompositeKey other = (ProductCompositeKey) obj;<br />if (groupId == null) {<br />if (other.groupId != null)<br />return false;<br />} else if (!groupId.equals(other.groupId))<br />return false;<br />if (productId == null) {<br />if (other.productId != null)<br />return false;<br />} else if (!productId.equals(other.productId))<br />return false;<br />return true;<br />}<br /><br />}<br /><br /></pre><br /><br /><br />The ProductCompositeKey class is annotated with the @Embeddable annotation. Note that it is not annotated with @Entity<br />We need to override equals() and hashcode() and also implement the Serializable interface to make hibernate happy.<br /><br /><br />Next we define DAO classes for the Product. Here's the ProductDao interface:<br /><pre name="code" class="java:collapse"><br />package sample.dao;<br /><br />import java.util.List;<br /><br />import sample.model.Product;<br /><br />public interface ProductDao {<br /><br />public boolean delete(final Product product);<br /><br />public boolean deleteById(final Long id);<br /><br />public Product findById(final Long id);<br /><br />public Product findByName(final String productName);<br /><br />public List<product> getAllProducts();<br /><br />public long getNumberOfProducts();<br /><br />public Product saveOrUpdate(final Product product);<br /><br />}<br /></pre><br /><br />And the ProductDaoImpl class:<br /><pre name="code" class="java:collapse"><br />package sample.dao;<br /><br />import java.util.List;<br /><br />import org.apache.log4j.Logger;<br /><br />import sample.model.Product;<br /><br />public class ProductDaoImpl implements ProductDao {<br />  private static final Logger logger = Logger.getLogger(ProductDaoImpl.class);<br /><br />  final DaoHelper     daoHelper;<br /><br />  public ProductDaoImpl(final DaoHelper daoHelper) {<br />    if (null == daoHelper) throw new IllegalArgumentException("daoHelper can't be null");<br />    this.daoHelper = daoHelper;<br />  }<br /><br />  public boolean delete(final Product product) {<br />    if (logger.isDebugEnabled()) logger.debug("delete: " + product.getId());<br />    <br />    return daoHelper.deleteById(Product.class, product.getId());<br />  }<br /><br />  public boolean deleteById(final Long id) {<br />    if (logger.isDebugEnabled()) logger.debug("deleteById: " + id);<br /><br />    return daoHelper.deleteById(Product.class, id);<br />  }<br /><br />  public Product findById(final Long id) {<br />    if (logger.isDebugEnabled()) logger.debug("findById: " + id);<br /><br />    return daoHelper.findById(Product.class, id);<br />  }<br /><br />  public Product findByName(final String productName) {<br />    if (logger.isDebugEnabled()) logger.debug("findByName: " + productName);<br /><br />    final List&lt;Product&gt; list = daoHelper.findByAttribute(Product.class, "name", productName);<br />    if (null == list || 0 == list.size()) return null;<br />    assert list.size() == 1;<br /><br />    return list.get(0);<br />  }<br /><br />  public List&lt;Product&gt; getAllProducts() {<br />    if (logger.isDebugEnabled()) logger.debug("getAllProducts");<br /><br />    return daoHelper.getAllEntities(Product.class);<br />  }<br /><br />  public long getNumberOfProducts() {<br />    if (logger.isDebugEnabled()) logger.debug("getNumberOfProducts");<br /><br />    return daoHelper.countEntities(Product.class);<br />  }<br /><br />  public Product saveOrUpdate(final Product product) {<br />    if (logger.isDebugEnabled()) logger.debug("saveOrUpdate: " + product);<br /><br />    if (null == product) throw new IllegalArgumentException("product can't be null");<br />    if (product.getId() == null) {<br />      return daoHelper.save(Product.class, product);<br />    } else {<br />      return daoHelper.update(Product.class, product);<br />    }<br />  }<br /><br />//  public PageData&lt;Product&gt; getProductsByPage(final PageRequest pageRequest) {<br />//    if (logger.isDebugEnabled()) logger.debug("getProductsByPage: pageRequest=" + pageRequest);<br />//    return daoHelper.getEntitiesByPage(Product.class, pageRequest, "isDeleted", Boolean.FALSE);<br />//  }<br />}<br /><br /></pre><br /><br />As you have seen, the ProductDaoImpl class delegates all its work to the DaoHelper class. The DaoHelper class is copied from the <a href="http://svn.terracotta.org/svn/forge/projects/exam/tags/release-1.0.0/src/main/java/org/terracotta/reference/exam/dao/impl/DaoHelper.java">Examinator project</a> (the api's related to paging are commented, as we don't need the paging api's here... hope to come up with a post for the paging soon).<br />The DaoHelper class is given here for reference:<br /><pre name="code" class="java:collapse"><br />package sample.dao;<br /><br />import java.util.List;<br /><br />import javax.persistence.EntityManager;<br />import javax.persistence.PersistenceContext;<br /><br />/**<br /> * The GenericDao is a helper class providing common data access functionality for use (via delegation) by Dao<br /> * implementations.<br /> */<br />public class DaoHelper {<br /><br />  @PersistenceContext<br />  private EntityManager entityManager;<br /><br />  /**<br />   * Defines ASC and DESC sort orders for queries.<br />   */<br />  public enum SortOrder {<br />    ASC, DESC<br />  }<br /><br />  public DaoHelper() {<br />    // entityManager will be set via JSR250 injection<br />  }<br /><br />  /**<br />   * Custom entity manager that will not automatically be injected.<br />   */<br />  public DaoHelper(final EntityManager entityManager) {<br />    this.entityManager = entityManager;<br />  }<br /><br />  public &lt;T&gt; T findById(final Class&lt;T&gt; entityClass, final Object id) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == id) throw new IllegalArgumentException("id can't be null");<br /><br />    return entityManager.find(entityClass, id);<br />  }<br /><br />  public boolean delete(final Object entity) {<br />    if (null == entity) throw new IllegalArgumentException("entity can't be null");<br /><br />    entityManager.remove(entity);<br />    return true;<br />  }<br /><br />  public &lt;T&gt; boolean deleteById(final Class&lt;T&gt; entityClass, final Object id) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == id) throw new IllegalArgumentException("id can't be null");<br /><br />    return delete(findById(entityClass, id));<br />  }<br /><br />  public int deleteByAttribute(final Class entityClass, final String attributeName, final Object attributeValue) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == attributeName) throw new IllegalArgumentException("attributeName can't be null");<br />    if (null == attributeValue) throw new IllegalArgumentException("attributeValue can't be null");<br /><br />    return entityManager.createQuery(<br />                                     "delete from " + entityClass.getSimpleName() + " e where e." + attributeName<br />                                         + " = ?1").setParameter(1, attributeValue).executeUpdate();<br />  }<br /><br />  public &lt;T&gt; List&lt;T&gt; findByAttribute(final Class&lt;T&gt; entityClass, final String attributeName, final Object attributeValue) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == attributeName) throw new IllegalArgumentException("attributeName can't be null");<br />    if (null == attributeValue) throw new IllegalArgumentException("attributeValue can't be null");<br /><br />    return entityManager.createQuery(<br />                                     "select e from " + entityClass.getSimpleName() + " e where e." + attributeName<br />                                         + " = ?1").setParameter(1, attributeValue).getResultList();<br />  }<br /><br />  public &lt;T&gt; List&lt;T&gt; findByAttribute(final Class&lt;T&gt; entityClass, final String attributeName,<br />                                     final Object attributeValue, final String orderByAttributeName,<br />                                     final SortOrder sortOrder) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == attributeName) throw new IllegalArgumentException("attributeName can't be null");<br />    if (null == attributeValue) throw new IllegalArgumentException("attributeValue can't be null");<br />    if (null == orderByAttributeName) throw new IllegalArgumentException("orderByAttributeName can't be null");<br /><br />    return entityManager.createQuery(<br />                                     "select e from " + entityClass.getSimpleName() + " e where e." + attributeName<br />                                         + " = ?1 ORDER BY e." + orderByAttributeName + " " + sortOrder.name())<br />        .setParameter(1, attributeValue).getResultList();<br />  }<br /><br />  public &lt;T&gt; List&lt;T&gt; getAllEntities(final Class&lt;T&gt; entityClass) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br /><br />    return entityManager.createQuery("select e from " + entityClass.getSimpleName() + " e").getResultList();<br />  }<br /><br />  public &lt;T&gt; List&lt;T&gt; getAllEntities(final Class&lt;T&gt; entityClass, final String orderByAttributeName,<br />                                    final SortOrder sortOrder) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == orderByAttributeName) throw new IllegalArgumentException("orderByAttributeName can't be null");<br /><br />    return entityManager.createQuery(<br />                                     "select e from " + entityClass.getSimpleName() + " e order by e."<br />                                         + orderByAttributeName + " " + sortOrder.name()).getResultList();<br />  }<br /><br />  public &lt;T&gt; T save(final Class&lt;T&gt; entityClass, final T entity) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == entity) throw new IllegalArgumentException("entity can't be null");<br /><br />    entityManager.persist(entity);<br />    return entity;<br />  }<br /><br />  public &lt;T&gt; T update(final Class&lt;T&gt; entityClass, final T entity) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == entity) throw new IllegalArgumentException("entity can't be null");<br /><br />    return entityManager.merge(entity);<br />  }<br /><br />  public long countEntities(final Class entityClass) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br /><br />    return (Long) entityManager.createQuery("select count(entity) from " + entityClass.getSimpleName() + " entity")<br />        .getSingleResult();<br />  }<br /><br />  public long countEntitiesByAttribute(final Class entityClass, final String attributeName, final Object attributeValue) {<br />    if (null == entityClass) throw new IllegalArgumentException("entityClass can't be null");<br />    if (null == attributeName) throw new IllegalArgumentException("attributeName can't be null");<br />    if (null == attributeValue) throw new IllegalArgumentException("attributeValue can't be null");<br /><br />    return (Long) entityManager.createQuery(<br />                                            "select count(e) from " + entityClass.getSimpleName() + " e where e."<br />                                                + attributeName + " = ?1").setParameter(1, attributeValue)<br />        .getSingleResult();<br />  }<br /><br />  // public &lt;T&gt; PageData&lt;T&gt; getEntitiesByPage(final Class&lt;T&gt; entityClass, final<br />  // PageRequest pageRequest) {<br />  // return getEntitiesByPage(entityClass, pageRequest, null, null, "id",<br />  // SortOrder.ASC);<br />  // }<br />  //<br />  // public &lt;T&gt; PageData&lt;T&gt; getEntitiesByPage(final Class&lt;T&gt; entityClass, final<br />  // PageRequest pageRequest, final String attributeName,<br />  // final Object attributeValue) {<br />  // return getEntitiesByPage(entityClass, pageRequest, attributeName,<br />  // attributeValue, "id", SortOrder.ASC);<br />  // }<br />  //<br />  // public &lt;T&gt; PageData&lt;T&gt; getEntitiesByPage(final Class&lt;T&gt; entityClass, final<br />  // PageRequest pageRequest, final String attributeName,<br />  // final Object attributeValue, final String orderByAttributeName,<br />  // final SortOrder sortOrder) {<br />  // if (null == entityClass) throw new<br />  // IllegalArgumentException("entityClass can't be null");<br />  // if (null == pageRequest) throw new<br />  // IllegalArgumentException("pageRequest can't be null");<br />  // if (null == orderByAttributeName) throw new<br />  // IllegalArgumentException("orderByAttributeName can't be null");<br />  //<br />  // String queryStr = "";<br />  // if (attributeName != null) {<br />  // queryStr = "select e from " + entityClass.getSimpleName() + " e where e." +<br />  // attributeName + " = ?1 ORDER BY e."<br />  // + orderByAttributeName + " " + sortOrder.name();<br />  // } else {<br />  // queryStr = "select e from " + entityClass.getSimpleName() +<br />  // " e ORDER BY e." + orderByAttributeName + " "<br />  // + sortOrder.name();<br />  // }<br />  // long total;<br />  // if (attributeName != null) total = countEntitiesByAttribute(entityClass,<br />  // attributeName, attributeValue);<br />  // else total = countEntities(entityClass);<br />  //    <br />  // final PageRequest newPageRequest =<br />  // PageRequest.adjustPageRequest(pageRequest, total);<br />  //    <br />  // Query query;<br />  // if (attributeName != null) query =<br />  // entityManager.createQuery(queryStr).setParameter(1, attributeValue);<br />  // else query = entityManager.createQuery(queryStr);<br />  // final List&lt;T&gt; data = query.setFirstResult(newPageRequest.getStart() -<br />  // 1).setMaxResults(newPageRequest.getPageSize()).getResultList();<br />  // return new PageData&lt;T&gt;(newPageRequest, total, data);<br />  // }<br />}<br /><br /><br /></pre>This is the class that does the main work for talking with your DB through JPA. You can note that the class does not have any compile time dependency on Spring or any other external library except for JPA. So if you are going to work with JPA, this class will make you happy :).<br />If you are thinking about writing your own dao's, you can consider reusing this class, its cool.<br /><br />Next, coming to the service classes, I'll add a ProductService class which can add/remove/list products (from the DB of course). Here's the interface:<br /><pre name="code" class="java:collapse"><br />package sample.service;<br /><br />import java.util.List;<br /><br />import sample.model.Product;<br /><br />public interface ProductService {<br /><br />public void addProduct(Product product);<br /><br />public void deleteProduct(Product product);<br /><br />public List&lt;product&gt; getAllProducts();<br />}<br /></pre><br /><br />The ProductServiceImpl implements the above interface:<br /><pre name="code" class="java:collapse"><br />package sample.service;<br /><br />import java.util.List;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Service;<br />import org.springframework.transaction.annotation.Transactional;<br /><br />import sample.dao.ProductDao;<br />import sample.model.Product;<br /><br />public class ProductServiceImpl implements ProductService {<br /><br />@Autowired<br />private ProductDao productDao;<br /><br />@Transactional(readOnly = false)<br />public void addProduct(Product product) {<br />try {<br />productDao.saveOrUpdate(product);<br />} catch (Exception e) {<br />e.printStackTrace();<br />throw new RuntimeException(e);<br />}<br />}<br /><br />@Transactional(readOnly = false)<br />public void deleteProduct(Product product) {<br />try {<br />productDao.delete(product);<br />} catch (Exception e) {<br />e.printStackTrace();<br />throw new RuntimeException(e);<br />}<br />}<br /><br />@Transactional(readOnly = true)<br />public List&lt;product&gt; getAllProducts() {<br />try {<br />return productDao.getAllProducts();<br />} catch (Exception e) {<br />e.printStackTrace();<br />throw new RuntimeException(e);<br />}<br />}<br /><br />}<br /><br /></pre><br /><br />You can see that I am using Spring's @Transactional annotation to demarcate my transactions. I will show you shortly how it is configured.<br />Am also using the @Autowired annotation, doing so I just need to declare a bean of type ProductDao and Spring will inject the bean into this ProductService bean. Saves me some xml in my application-context file from instead of explicitly setting the dao bean ;-)<br /><br />And here's my application-context file:<br /><br /><pre name="code" class="xml:collapse"><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xmlns:context="http://www.springframework.org/schema/context"<br /> xsi:schemaLocation="<br />   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd<br />   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;<br /><br /> <br /> &lt;context:annotation-config /&gt;<br /> <br /> &lt;bean id="productService" class="sample.service.ProductServiceImpl" /&gt;<br /> <br /> &lt;bean id="daoHelper" class="sample.dao.DaoHelper" /&gt;<br /> &lt;bean id="productDao" class="sample.dao.ProductDaoImpl"&gt;<br />  &lt;constructor-arg ref="daoHelper" /&gt;<br /> &lt;/bean&gt;<br /> &lt;import resource="data-access.xml"/&gt;<br />&lt;/beans&gt;<br /></pre><br /><br />This just declares my beans and imports the data-access.xml which configures my settings for talking with the DB.<br /><br />Here's the data-access.xml:<br /><textarea name="code" class="xml:collapse"><br /><?xml version="1.0" encoding="UTF-8"?><br /><beans xmlns="http://www.springframework.org/schema/beans" xsi="http://www.w3.org/2001/XMLSchema-instance" tx="http://www.springframework.org/schema/tx" schemalocation="            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"><br />           <br /> <!-- Instructs Spring to perform declarative transaction management on annotated classes --><br /> <tx:annotation-driven><br /> <br /> <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"><br />  <property name="location" value="classpath:jdbc.properties"><br />  <!-- This PPC does not need to resolve every placeholder; needed to support multiple PPCs --><br />  <property name="ignoreUnresolvablePlaceholders" value="true"><br /> </bean><br /> <br /><br /> <!-- Drives transactions using local JPA APIs --><br /> <bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"><br />  <property name="entityManagerFactory" ref="entityManagerFactory"><br /> </bean><br /> <br /> <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"><br />  <property name="dataSource" ref="dataSource"><br />  <property name="jpaVendorAdapter" ref="hibernateJpaVendorAdapter"><br />  <property name="persistenceUnitName" value="samplewebapp"><br />  <property name="jpaProperties"><br />   <value><br />    # Tooling<br />    hibernate.dialect=${hibernate.dialect}<br />    hibernate.hbm2ddl.auto=${hibernate.hbm2ddl.auto}<br />    <br />    # Debugging / logging<br />    hibernate.show_sql=${hibernate.show_sql}<br />    hibernate.format_sql=${hibernate.format_sql}<br />    hibernate.use_sql_comments=${hibernate.use_sql_comments}<br />    hibernate.generate_statistics=${hibernate.generate_statistics}<br /><br />    # Auto-detect annotated JPA entities<br />    hibernate.archive.autodetection=class<br />   <br />    # Caching<br />    hibernate.cache.provider_class=net.sf.ehcache.hibernate.SingletonEhCacheProvider<br />    hibernate.cache.use_query_cache=false<br />    hibernate.cache.use_second_level_cache=true<br />   </value><br />  </property><br /> </bean><br /> <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" method="close"><br />  <!-- Connection Info --><br />  <property name="driverClassName" value="${jdbc.driverClassName}"><br />  <property name="url" value="${jdbc.url}"><br />  <property name="username" value="${jdbc.username}"><br />  <property name="password" value="${jdbc.password}"><br />  <br />  <!-- Connection Pooling DBCP --><br />  <property name="initialSize" value="5"><br />  <property name="maxActive" value="100"><br />  <property name="maxIdle" value="30"><br />  <property name="maxWait" value="1000"><br />  <property name="poolPreparedStatements" value="true"><br />  <property name="defaultAutoCommit" value="false"><br /> </bean><br /> <bean id="hibernateJpaVendorAdapter" class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"><br />  <property name="showSql" value="true"><br />  <property name="generateDdl" value="false"><br /> </bean><br /></beans><br /><br /></textarea><br /><br />The <tx:annotation-driven> tag tells Spring to provide transactions to my annotated classes (ProductServiceImpl class).<br /><br />I am configuring my properties from a properties file called "jdbc.properties" from the classpath.<br />I am using commons-dbcp connection pooling library and hence the org.apache.commons.dbcp.BasicDataSource datasource property for the LocalContainerEntityManagerFactoryBean<br /><br />We are using ehcache as the hibernate second-level cache provider.<br />We are setting hibernate.cache.use_second_level_cache to true to enable hibernate second level caching and using net.sf.ehcache.hibernate.SingletonEhCacheProvider as the cache provider.<br /><br />The name of the Persistence unit is samplewebapp as defined in the META-INF/persistence.xml (which basically contains nothing other than the PU name)<br /><textarea name="code" class="xml:collapse"><br /><persistence xmlns="http://java.sun.com/xml/ns/persistence" xsi="http://www.w3.org/2001/XMLSchema-instance" schemalocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" version="1.0"><br /> <persistence-unit name="samplewebapp"><br /></persistence><br /></textarea><br /><br />Here's my jdbc.properties:<br /><pre name="code" class="properties:collapse"><br />## Properties file for JDBC settings<br /><br />##-----------------<br /># MySQL DB Settings<br />##-----------------<br />jdbc.driverClassName=com.mysql.jdbc.Driver<br />jdbc.url=jdbc:mysql://localhost:3306/samplewebapp?createDatabaseIfNotExist=true&amp;useUnicode=true&amp;characterEncoding=utf-8<br />jdbc.username=root<br />jdbc.password=<br /><br /><br />##--------------------<br /># Hibernate properties<br />##--------------------<br />hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect<br />hibernate.hbm2ddl.auto=validate<br /><br /># Debugging<br />hibernate.show_sql=false<br />hibernate.format_sql=true<br />hibernate.use_sql_comments=true<br />hibernate.generate_statistics=false<br /><br /></pre><br /><br /><br />We need to add dependency on all these libraries that we are using - spring, persistence-api (JPA), hibernate, ehcache, dbcp, mysql connector classes etc. This is declared in pom.xml<br /><textarea name="code" class="xml:collapse"><br /><project xmlns="http://maven.apache.org/POM/4.0.0" xsi="http://www.w3.org/2001/XMLSchema-instance" schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"><br /> <modelversion>4.0.0</modelversion><br /> <groupid>sample</groupid><br /> <artifactid>hibernateEhcacheTest</artifactid><br /> <packaging>jar</packaging><br /> <version>0.0.1-SNAPSHOT</version><br /> <name>hibernateEhcacheTest</name><br /> <url>http://maven.apache.org</url><br /> <dependencies><br />  <dependency><br />   <groupid>junit</groupid><br />   <artifactid>junit</artifactid><br />   <version>3.8.1</version><br />   <scope>test</scope><br />  </dependency><br />  <dependency><br />   <artifactid>spring-aop</artifactid><br />   <version>${spring.version}</version><br />   <groupid>org.springframework</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>spring-beans</artifactid><br />   <version>${spring.version}</version><br />   <groupid>org.springframework</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>spring-context</artifactid><br />   <version>${spring.version}</version><br />   <groupid>org.springframework</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>spring-core</artifactid><br />   <version>${spring.version}</version><br />   <groupid>org.springframework</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>spring-dao</artifactid><br />   <version>${spring-ext.version}</version><br />   <groupid>org.springframework</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>spring-jdbc</artifactid><br />   <version>${spring.version}</version><br />   <groupid>org.springframework</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>spring-orm</artifactid><br />   <version>${spring.version}</version><br />   <groupid>org.springframework</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>persistence-api</artifactid><br />   <version>${persistence-api.version}</version><br />   <groupid>javax.persistence</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>commons-dbcp</artifactid><br />   <version>${commons-dbcp.version}</version><br />   <scope>compile</scope><br />   <groupid>commons-dbcp</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>hibernate</artifactid><br />   <version>${hibernate.version}</version><br />   <groupid>org.hibernate</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>hibernate-annotations</artifactid><br />   <version>${hibernate-annotations.version}</version><br />   <groupid>org.hibernate</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>hibernate-entitymanager</artifactid><br />   <version>${hibernate-entitymanager.version}</version><br />   <groupid>org.hibernate</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>hibernate-validator</artifactid><br />   <version>${hibernate-validator.version}</version><br />   <groupid>org.hibernate</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>hibernate-commons-annotations</artifactid><br />   <version>${hibernate-commons-annotations.version}</version><br />   <groupid>org.hibernate</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>concurrent</artifactid><br />   <version>${concurrent.version}</version><br />   <groupid>concurrent</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>mysql-connector-java</artifactid><br />   <version>${mysql.version}</version><br />   <scope>compile</scope><br />   <groupid>mysql</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>log4j</artifactid><br />   <version>${log4j.version}</version><br />   <groupid>log4j</groupid><br />   <exclusions><br />    <exclusion><br />     <groupid>javax.jms</groupid><br />     <artifactid>jms</artifactid><br />    </exclusion><br />    <exclusion><br />     <groupid>com.sun.jdmk</groupid><br />     <artifactid>jmxtools</artifactid><br />    </exclusion><br />    <exclusion><br />     <groupid>com.sun.jmx</groupid><br />     <artifactid>jmxri</artifactid><br />    </exclusion><br />    <exclusion><br />     <groupid>javax.mail</groupid><br />     <artifactid>mail</artifactid><br />    </exclusion><br />   </exclusions><br />  </dependency><br />  <dependency><br />   <artifactid>ehcache</artifactid><br />   <version>${ehcache.version}</version><br />   <groupid>net.sf.ehcache</groupid><br />  </dependency><br />  <dependency><br />   <artifactid>tim-hibernate-3.2.5</artifactid><br />   <version>${tim-hibernate-3.2.5.version}</version><br />   <groupid>org.terracotta.modules</groupid><br />   <scope>provided</scope><br />  </dependency><br />  <dependency><br />   <artifactid>tim-ehcache-1.3</artifactid><br />   <version>${tim-ehcache-1.3.version}</version><br />   <groupid>org.terracotta.modules</groupid><br />   <scope>provided</scope><br />  </dependency><br /> </dependencies><br /> <properties><br />  <spring-ext.version>2.0.7</spring-ext.version><br />  <spring.version>2.5.4</spring.version><br />  <persistence-api.version>1.0</persistence-api.version><br />  <commons-dbcp.version>1.2.2</commons-dbcp.version><br />  <hibernate-commons-annotations.version>3.0.0.ga</hibernate-commons-annotations.version><br />  <hibernate-annotations.version>3.3.1.GA</hibernate-annotations.version><br />  <hibernate-entitymanager.version>3.3.1.ga</hibernate-entitymanager.version><br />  <hibernate-validator.version>3.0.0.ga</hibernate-validator.version><br />  <hibernate.version>3.2.5.ga</hibernate.version><br />  <concurrent.version>1.3.4</concurrent.version><br />  <mysql.version>5.0.5</mysql.version><br />  <hibernate3-plugin.version>2.1</hibernate3-plugin.version><br />  <log4j.version>1.2.15</log4j.version><br />  <ehcache.version>1.3.0</ehcache.version><br />  <tim-hibernate-3.2.5.version>1.2.1</tim-hibernate-3.2.5.version><br />  <tim-ehcache-1.3.version>1.2.1</tim-ehcache-1.3.version><br /> </properties><br /> <build><br />  <plugins><br />   <plugin><br />    <artifactid>hibernate3-maven-plugin</artifactid><br />    <version>${hibernate3-plugin.version}</version><br />    <groupid>org.codehaus.mojo</groupid><br />    <configuration><br />     <componentproperties><br />      <implementation>jpaconfiguration</implementation><br />      <propertyfile>target/classes/hibernate3hbm2ddl.properties</propertyfile><br />      <drop>true</drop><br />      <export>true</export><br />      <outputfilename>schema.sql</outputfilename><br />     </componentproperties><br />    </configuration><br />   </plugin><br />   <plugin><br />    <artifactid>maven-compiler-plugin</artifactid><br />    <groupid>org.apache.maven.plugins</groupid><br />    <configuration><br />     <source>1.5</source><br />     <target>1.5</target><br />    </configuration><br />   </plugin><br />  </plugins><br />  <extensions><br />   <extension><br />    <artifactid>mysql-connector-java</artifactid><br />    <version>${mysql.version}</version><br />    <groupid>mysql</groupid><br />   </extension><br />  </extensions><br /> </build><br /> <pluginrepositories><br />  <pluginrepository><br />   <id>terracotta-repository</id><br />   <url>http://www.terracotta.org/download/reflector/maven2</url><br />   <releases><br />    <enabled>true</enabled><br />   </releases><br />   <snapshots><br />    <enabled>true</enabled><br />   </snapshots><br />  </pluginrepository><br />  <pluginrepository><br />   <id>mortbay-snapshot-repo</id><br />   <name>MortBay Snapshot Repo</name><br />   <url>http://jetty.mortbay.org/maven2/snapshot</url><br />   <releases><br />    <enabled>false</enabled><br />   </releases><br />   <snapshots><br />    <enabled>true</enabled><br />   </snapshots><br />  </pluginrepository><br /> </pluginrepositories><br /></project><br /></textarea><br /><br /><br />Now the last thing that we need is the main class that will demonstrate all these glued together.<br />Here's the main class that I am using to drive the App,<br /><br /><pre name="code" class="java:collapse"><br />package sample;<br /><br />import java.util.List;<br />import java.util.Random;<br />import java.util.UUID;<br /><br />import org.springframework.context.ApplicationContext;<br />import org.springframework.context.support.ClassPathXmlApplicationContext;<br /><br />import sample.model.Product;<br />import sample.service.ProductService;<br /><br />public class App {<br /><br />private static Random random = new Random();<br /><br />public static final ApplicationContext ctxt;<br />static {<br /> ctxt = new ClassPathXmlApplicationContext("application-context.xml");<br />}<br /><br />private ProductService productService = (ProductService) ctxt.getBean("productService");<br /><br />public static void main(String[] args) {<br /> new App().test();<br />}<br /><br />private void test() {<br /> listProducts();<br /> addRandomProducts(random.nextInt(10) + 1);<br /> listProducts();<br />}<br /><br />private void addRandomProducts(int numProducts) {<br /> System.out.println("======= Adding " + numProducts + " random products...");<br /> for (int i = 0; i <> allProducts = productService.getAllProducts();<br /> System.out.println("Number of products: " + allProducts.size());<br /> for (Product prod : allProducts) {<br />   System.out.println("Product: " + prod);<br /> }<br />}<br /><br />private Product getRandomProduct() {<br /> Product product = new Product();<br /> product.setProductId(Long.valueOf(UUID.randomUUID().getLeastSignificantBits()));<br /> product.setGroupId(Long.valueOf(UUID.randomUUID().getLeastSignificantBits()));<br /> product.setDescription("A description : " + System.currentTimeMillis());<br /> return product;<br />}<br />}<br /></pre><br /><br /><br />You can try out running this class using<br /><pre class="console"><br /><br />$ mvn exec:java -Dexec.mainClass=sample.App<br /><br /><br /></pre><br /><br /><br />Now the interesting part: clustering the app with Terracotta.<br />For this we create a tc-config.xml and just tell Terracotta that we are using hibernate and ehcache and it will automatically cluster the app.<br /><textarea name="code" class="xml:collapse"><br /><?xml version="1.0" encoding="UTF-8"?><br /><tc:tc-config tc="http://www.terracotta.org/config" xsi="http://www.w3.org/2001/XMLSchema-instance" schemalocation="http://www.terracotta.org/config http://www.terracotta.org/schema/terracotta-4.xsd"><br /> <servers><br />  <server name="localhost" host="localhost"><br />   <dso-port>9510</dso-port><br />   <jmx-port>9520</jmx-port><br />   <data>target/terracotta/server/data</data><br />   <logs>target/terracotta/server/logs</logs><br />   <statistics>target/terracotta/server/statistics</statistics><br />  </server><br /> </servers><br /> <clients><br />  <logs>target/terracotta/clients/logs/%(tc.nodeName)</logs><br />    <statistics>target/terracotta/clients/statistics/%(tc.nodeName)</statistics><br />    <modules><br />      <module name="tim-hibernate-3.2.5" version="1.2.1"><br />      <module name="tim-ehcache-1.3" version="1.2.1"><br />      <module name="clustered-commons-collections-3.1" version="2.7.1"><br />    </modules><br />  </clients><br />  <application><br />    <dso><br />     <instrumented-classes><br />         <include><br />           <class-expression>sample.model.ProductCompositeKey</class-expression><br />         </include><br />         </instrumented-classes><br />    </dso><br />  </application><br /></tc:tc-config><br /><br /></textarea><br /><br />That's all that's needed to cluster with Terracotta.<br />Here's a script that will launch the app with Terracotta, just replace the TC_INSTALL_DIR with the location where you have <a href="http://terracotta.org/web/display/orgsite/DownloadCatalog">downloaded</a> and installed Terracotta:<br /><br /><pre name="code" class="bash:collapse"><br />#!/bin/bash<br /><br />TC_INSTALL_DIR=/Users/asingh/terracottaKit/terracotta-2.7.1<br /><br />mvn compile<br /><br />CP_FILE=cp.txt<br />mvn dependency:build-classpath -Dmdep.outputFile=$CP_FILE<br />echo ":./target/classes"  >> $CP_FILE<br /><br />$TC_INSTALL_DIR/bin/dso-java.sh -cp `cat $CP_FILE` sample.App<br /><br />rm $CP_FILE<br /><br /></pre><br /><br /><br />I am sure I must have missed some parts of explaining the glue-points here and there.<br />You can download the attached tarball from <a href="http://forums.terracotta.org/forums/posts/downloadAttach/721.page">here</a> and play around with this simple app.<br /><br />Looks like this was quite a long (hopefully not boring) post. Hope you are still with me and reading this :)... and do leave a comment if you are <span style="font-weight: bold;">not</span> reading this ;-)<img src="http://feeds.feedburner.com/~r/abhisanoujam-blogspot/~4/o-O5AMTxMB4" height="1" width="1"/>