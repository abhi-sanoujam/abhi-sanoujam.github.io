---           
layout: post
title: Odd Even printing threads... in multiple jvms -- Terracotta wow factor!
date: 2009-01-31 16:51:42 UTC
updated: 2009-01-31 16:51:42 UTC
comments: false
categories: 
---
 
Recently I got a comment asking about a small use-case demostrating <a href="http://terracotta.org/">Terracotta</a><br /><br />I hacked up a small app in which there are 2 threads (can be more), and each thread is printing numbers sequentially, each thread printing one after another.<br />With 2 threads, one of them will print odd numbers, and the other will print even numbers... when we have multiple number of threads, we want each thread to print one after another, the threads executing serially.<br /><br />So lets take a look at the classes.<br />First, lets have a Counter class that will maintain the current value ...<br /><pre name="code" class="java:collapse"><br />/**<br /> * Jan 28, 2009<br /> * @author abhi.sanoujam<br /> */<br />package sample;<br /><br />public class Counter {<br />  private final int numParties;<br />  private int value = 0;<br />  private final int maxValue;<br /><br />  public Counter(int numParties, int maxValue) {<br />    this.numParties = numParties;<br />    this.maxValue = maxValue;<br />  }<br /><br />  public synchronized boolean isMyTurn(int partyNum) {<br />    return value % numParties == partyNum;<br />  }<br /><br />  public synchronized void setValue(int val) {<br />    this.value = val;<br />  }<br /><br />  public int getMaxValue() {<br />    return maxValue;<br />  }<br /><br />  public synchronized boolean isMaxValueReached() {<br />    return value >= maxValue;<br />  }<br /><br />  public synchronized int increment() {<br />    this.value++;<br />    return value;<br />  }<br /><br />  public synchronized int getValue() {<br />    return value;<br />  }<br />}<br /></pre><br /><br />Here's the Runnable class that each thread will be using:<br /><pre name="code" class="java:collapse"><br /><br />/**<br />* Jan 28, 2009<br />* @author abhi.sanoujam<br />*/<br />package sample;<br /><br />import java.util.concurrent.CyclicBarrier;<br /><br />public class OddEvenRunnable implements Runnable {<br /><br />private final Counter counter;<br />private final int partyId;<br />private final CyclicBarrier barrier;<br /><br />public OddEvenRunnable(int partyId, Counter counter, CyclicBarrier barrier) {<br />  this.partyId = partyId;<br />  this.counter = counter;<br />  this.barrier = barrier;<br />}<br /><br />public void run() {<br />  try {<br />    System.out.println(Thread.currentThread().getName() + ": Waiting for GREEN signal from main guy...");<br />    barrier.await();<br />  } catch (Exception e) {<br />    e.printStackTrace();<br />  }<br />  while (true) {<br />    synchronized (counter) {<br />      while (!(counter.isMyTurn(partyId) || counter.isMaxValueReached())) {<br />        try {<br />          counter.wait();<br />        } catch (InterruptedException e) {<br />          System.out.println(partyId + ": Got Interrupted. Continuing for my turn...");<br />        }<br />      }<br />      if (counter.isMaxValueReached()) {<br />        // make sure other-threads don't keep waiting for my signal when I'm<br />        // leaving<br />        counter.notifyAll();<br />        break;<br />      }<br />      int value = counter.increment();<br />      System.out.println(Thread.currentThread().getName() + ": Counter Value=" + value);<br />      try {<br />        Thread.sleep(500);<br />      } catch (InterruptedException e) {<br />        // ignored<br />      }<br />      counter.notifyAll();<br />    }<br />  }<br /><br />  System.out.println(Thread.currentThread().getName() + ": DONE!!");<br />}<br /><br />}<br /><br /></pre><br /><br /><br />Here's the Main class that drives the app.<br /><br /><pre name="code" class="java:collapse"><br />/**<br /> * Jan 28, 2009<br /> * @author abhi.sanoujam<br /> */<br />package sample;<br /><br />import java.util.HashSet;<br />import java.util.Set;<br />import java.util.concurrent.BrokenBarrierException;<br />import java.util.concurrent.CyclicBarrier;<br /><br />public class Main {<br /><br />  private final int numParties;<br />  <br />  // @Root<br />  private final Counter counter;<br />  // @Root<br />  private final Set<String> runners = new HashSet<String>();<br />  // @Root<br />  private final CyclicBarrier barrier;<br />  private final Thread[] parties;<br /><br />  public Main(int numParties, int maxCounterValue) {<br />    this.numParties = numParties;<br />    counter = new Counter(numParties, maxCounterValue);<br />    barrier = new CyclicBarrier(numParties + 1);<br />    parties = new Thread[numParties];<br /><br />    for (int i = 0; i < numParties; i++) {<br />      parties[i] = new Thread(new OddEvenRunnable(i, counter, barrier), getThreadName(i));<br />    }<br />  }<br /><br />  private void runInSingleJvm() throws BrokenBarrierException, InterruptedException {<br />    // start all the counting parties<br />    for (int i = 0; i < numParties; i++) {<br />      parties[i].start();<br />    }<br />    startCounting();<br />  }<br /><br />  private void startCounting() throws InterruptedException, BrokenBarrierException {<br />    System.out.println(Thread.currentThread().getName() + ": Sleeping for 1 secs....");<br />    Thread.sleep(1000);<br />    System.out.println(Thread.currentThread().getName() + ": ... And letting all the counting threads go!!");<br />    // let thy parties proceed<br />    barrier.await();<br />  }<br /><br />  private String getThreadName(int partyNum) {<br />    String prefix = "";<br />    for (int i = 0; i < partyNum; i++) {<br />      prefix += "  ";<br />    }<br />    return prefix + "Party-" + partyNum;<br />  }<br /><br />  public static void main(String[] args) throws Exception {<br />    Main main = new Main(2, 30);<br />    if (args.length == 0) {<br />      // run in a single node/jvm<br />      main.runInSingleJvm();<br />    } else {<br />      if (args.length != 1) {<br />        printUsageAndExit();<br />      }<br />      if ("odd".equals(args[0])) {<br />        main.startFirstThread();<br />      } else if ("even".equals(args[0])) {<br />        main.startSecondThread();<br />      } else if ("main".equals(args[0])) {<br />        main.startMainThread();<br />      } else if ("reset".equals(args[0])) {<br />        main.reset();<br />      } else<br />        printUsageAndExit();<br />    }<br /><br />  }<br /><br />  private void reset() {<br />    for (int i = 0; i < numParties; i++) {<br />      parties[i] = new Thread(new OddEvenRunnable(i, counter, barrier), getThreadName(i));<br />    }<br />    synchronized (runners) {<br />      this.runners.clear();<br />      counter.setValue(0);<br />    }<br />    System.out.println("Reset Done.");<br />  }<br /><br />  private void startMainThread() throws Exception {<br />    if (runners.size() != 2) {<br />      System.out.println("Make sure that you have started both the odd and even threads.");<br />      printUsageAndExit();<br />    }<br />    synchronized (runners) {<br />      runners.add("main");<br />    }<br />    startCounting();<br />  }<br /><br />  private void startSecondThread() {<br />    if (runners.contains("even")) {<br />      System.out.println("You have already started the even-printing thread.");<br />      printUsageAndExit();<br />    }<br />    synchronized (runners) {<br />      runners.add("even");<br />    }<br />    parties[1].start();<br />    System.out.println("Started even thread");<br />  }<br /><br />  private void startFirstThread() {<br />    if (runners.contains("odd")) {<br />      System.out.println("You have already started the odd-printing thread.");<br />      printUsageAndExit();<br />    }<br />    synchronized (runners) {<br />      runners.add("odd");<br />    }<br />    parties[0].start();<br />    System.out.println("Started odd thread");<br />  }<br /><br />  private static void printUsageAndExit() {<br />    System.out.println("USAGE: java Main [odd | even | main | reset]");<br />    System.out.println("   No-arguments - Starts 2 threads printing odd and even values in single jvm.");<br />    System.out.println("   odd - starts the odd-number printing thread in this node.");<br />    System.out.println("   even - starts the even-number printing thread in this node.");<br />    System.out.println("   main - starts a thread which lets the odd and even threads go ahead.");<br />    System.out.println("   reset - Resets all states so you can start all over again.");<br />    System.exit(1);<br />  }<br /><br />}<br /><br /></pre><br /><br /><br />When running in a single-node (without Terracotta), the only method of interest is runInSingleJvm().<br /><br />You can check-out the code, a maven project, from <a href="http://abhi-sanoujam-blogspot-posts.googlecode.com/svn/trunk/terracotta-in-action/">http://abhi-sanoujam-blogspot-posts.googlecode.com/svn/trunk/terracotta-in-action/</a><br />using "svn checkout http://abhi-sanoujam-blogspot-posts.googlecode.com/svn/trunk/terracotta-in-action/ "<br /><br />You can run in a single node like:<br /><pre class="console"><br /><br />$ mvn exec:java -Dexec.mainClass=sample.Main<br /><br /></pre><br />Or you can even use regular java for doing it:<br /><pre class="console"><br /><br />$ mvn compile<br />$ java -cp target/classes/ sample.Main<br /><br /></pre><br /><br />You should be seeing some output like:<br /><pre class="console"><br /><br />sample.Main.main(): Sleeping for 1 secs....<br />Party-0: Waiting for GREEN signal from main guy...<br />  Party-1: Waiting for GREEN signal from main guy...<br />sample.Main.main(): ... And letting all the counting threads go!!<br />Party-0: Counter Value=1<br />  Party-1: Counter Value=2<br />Party-0: Counter Value=3<br />  Party-1: Counter Value=4<br />Party-0: Counter Value=5<br />  Party-1: Counter Value=6<br />Party-0: Counter Value=7<br />  Party-1: Counter Value=8<br />Party-0: Counter Value=9<br />  Party-1: Counter Value=10<br />Party-0: Counter Value=11<br />  Party-1: Counter Value=12<br />Party-0: Counter Value=13<br />  Party-1: Counter Value=14<br />Party-0: Counter Value=15<br />  Party-1: Counter Value=16<br />Party-0: Counter Value=17<br />  Party-1: Counter Value=18<br />Party-0: Counter Value=19<br />  Party-1: Counter Value=20<br />Party-0: Counter Value=21<br />  Party-1: Counter Value=22<br />Party-0: Counter Value=23<br />  Party-1: Counter Value=24<br />Party-0: Counter Value=25<br />  Party-1: Counter Value=26<br />Party-0: Counter Value=27<br />  Party-1: Counter Value=28<br />Party-0: Counter Value=29<br />  Party-1: Counter Value=30<br />Party-0: DONE!!<br />  Party-1: DONE!!<br /><br /></pre><br /><br />We create two threads and the two threads wait on a barrier. The main thread when calls "startCounting()" method, makes the two waiting threads proceed.<br />You can see that the two threads are running sequentially, one by one. Each thread printing the next value on the counter, one thread prints odd numbers and the other thread prints even numbers.<br /><br />Nice and cool. For testing, we can even change the number of parties when calling the Main constructor by passing in the required number of parties. E.g. if we pass in 5, then there will be 5 threads and each thread will print the counter sequentially, the threads executing one after another.<br /><br />Now here comes the wow-after-cool part :)<br />With Terracotta, you can make the threads run on different jvm's and the threads will co-ordinate with each other -- while running in different JVM's. <a href="http://abhisanoujam.blogspot.com/2008/10/definitely-terracotta.html">Imagine doing Object.wait() on one jvm and another thread Object.notify()'ing from another thread</a>... <br /><br />OK, lets have a look at the tc-config.xml for this..., oh by the way, if you are new to Terracotta, you don't need any code-level change to make it work cross-jvm, you just plug in a tc-config and start up with terracotta.<br /><br />Lets have a look at the tc-config for this app:<br /><pre name="code" class="xml:collapse"><br /><br />&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;tc:tc-config<br /> xmlns:tc="http://www.terracotta.org/config"<br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="http://www.terracotta.org/config http://www.terracotta.org/schema/terracotta-4.xsd"&gt;<br /> &lt;servers&gt;<br />  &lt;server<br />   name="localhost"<br />   host="localhost"&gt;<br />   &lt;dso-port&gt;9510&lt;/dso-port&gt;<br />   &lt;jmx-port&gt;9520&lt;/jmx-port&gt;<br />   &lt;data&gt;target/terracotta/server/data&lt;/data&gt;<br />   &lt;logs&gt;target/terracotta/server/logs&lt;/logs&gt;<br />   &lt;statistics&gt;target/terracotta/server/statistics&lt;/statistics&gt;<br />  &lt;/server&gt;<br /> &lt;/servers&gt;<br /> &lt;clients&gt;<br />  &lt;logs&gt;target/terracotta/clients/logs/%(tc.nodeName)%D&lt;/logs&gt;<br />     &lt;statistics&gt;target/terracotta/clients/statistics/%(tc.nodeName)%D&lt;/statistics&gt;<br />  &lt;/clients&gt;<br /><br />  &lt;application&gt;<br />    &lt;dso&gt;<br />     &lt;roots&gt;<br />      &lt;root&gt;<br />       &lt;field-name&gt;sample.Main.counter&lt;/field-name&gt;<br />      &lt;/root&gt;<br />      &lt;root&gt;<br />       &lt;field-name&gt;sample.Main.runners&lt;/field-name&gt;<br />      &lt;/root&gt;<br />      &lt;root&gt;<br />       &lt;field-name&gt;sample.Main.barrier&lt;/field-name&gt;<br />      &lt;/root&gt;<br />     &lt;/roots&gt;<br />     &lt;locks&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;write&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.Main.reset()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;write&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.Main.start*()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;write&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.OddEvenRunnable.run()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;write&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.Counter.increment()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;write&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.Counter.setValue()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;read&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.Counter.isMaxValueReached()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;read&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.Counter.getValue()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />      &lt;autolock&gt;<br />       &lt;lock-level&gt;read&lt;/lock-level&gt;<br />       &lt;method-expression&gt;* sample.Counter.isMyTurn()&lt;/method-expression&gt;<br />      &lt;/autolock&gt;<br />     &lt;/locks&gt;<br />     &lt;instrumented-classes&gt;<br />      &lt;include&gt;<br />       &lt;class-expression&gt;sample.Counter&lt;/class-expression&gt;<br />      &lt;/include&gt;<br />      &lt;include&gt;<br />       &lt;class-expression&gt;sample.OddEvenRunnable&lt;/class-expression&gt;<br />      &lt;/include&gt;<br />     &lt;/instrumented-classes&gt;<br />    &lt;/dso&gt;<br />  &lt;/application&gt;<br />&lt;/tc:tc-config&gt;<br /><br /></pre><br /><br /><br />You define roots and provide auto-locking for your methods in which you are synchronizing. You should probably go <a href="http://terracotta.org/web/display/docs/Concept+and+Architecture+Guide">here</a> if you want to read more.<br /><br />Roots are basically objects that get shared across the cluster. You can note that the <tt>counter</tt> object is a root, thats how the threads in different nodes are going to get the updated value in each node.<br /><br />For demo purpose, I've written the Main class to take arguments to start up in a parametrized way across the cluster, so that you can start the threads individually across different nodes.<br /><br />Here's the script that I'm using to run with Terracotta (runWithTc.sh). (Again, you can find the whole project <a href="http://abhi-sanoujam-blogspot-posts.googlecode.com/svn/trunk/terracotta-in-action/">here</a>)<br /><br /><pre name="code" class="bash:collapse"><br />#!/bin/bash<br /><br />TC_INSTALL_DIR=/Users/asingh/terracottaKit/terracotta-2.7.1<br /><br />mvn compile<br /><br />CP_FILE=cp.txt<br />mvn dependency:build-classpath -Dmdep.outputFile=$CP_FILE<br />echo ":./target/classes"  >> $CP_FILE<br /><br />$TC_INSTALL_DIR/bin/dso-java.sh -cp `cat $CP_FILE` sample.Main $*<br /><br />if [[ -f $CP_FILE ]]<br />then<br /> rm $CP_FILE<br />fi<br /></pre><br /><br />Change <tt>TC_INSTALL_DIR</tt> with the path where you have installed Terracotta.<br /><br />First, you need to start the Terracotta-server. Go to $TC_INSTALL_DIR/bin and type<br /><pre class="console"><br /><br />./start-tc-server.sh<br /><br /></pre><br />This should start the Terracotta server in localhost (note that we have referred to 'localhost' in the server-section in tc-config.xml. You can always run this in multiple machines too if you so desire).<br /><br />To start the Odd printing thread, run it like:<br /><pre class="console"><br /><br />$ ./runWithTc.sh odd<br /><br /></pre><br />You should see an output something like:<br /><pre class="console"><br />Started odd thread<br />Party-0: Waiting for GREEN signal from main guy...<br /></pre><br /><br />Now on another terminal/console, start the Even-printing thread like:<br /><pre class="console"><br /><br />$ ./runWithTc.sh even<br /><br /></pre><br />Again, you should see some output like:<br /><pre class="console"><br />Started even thread<br />  Party-1: Waiting for GREEN signal from main guy...<br /></pre><br /><br />Now you have 2 different threads started in different jvm's and both the threads are waiting on the shared barrier.<br />Lets start the main thread which will make the threads go ahead. Open another terminal/console and type in the following:<br /><pre class="console"><br /><br />$ ./runWithTc.sh main<br /><br /></pre><br /><br />You should be seeing an output like this:<br /><pre class="console"><br />main: Sleeping for 1 secs....<br />main: ... And letting all the counting threads go!!<br /></pre><br /><br />Now, at this point you can see that the other two threads in the other jvm's have started to run. The output in the console's should be like this:<br /><pre class="console"><br />Started odd thread<br />Party-0: Waiting for GREEN signal from main guy...<br />Party-0: Counter Value=1<br />Party-0: Counter Value=3<br />Party-0: Counter Value=5<br />Party-0: Counter Value=7<br />Party-0: Counter Value=9<br />Party-0: Counter Value=11<br />Party-0: Counter Value=13<br />Party-0: Counter Value=15<br />Party-0: Counter Value=17<br />Party-0: Counter Value=19<br />Party-0: Counter Value=21<br />Party-0: Counter Value=23<br />Party-0: Counter Value=25<br />Party-0: Counter Value=27<br />Party-0: Counter Value=29<br />Party-0: DONE!!<br /></pre><br /><br />And for the even-printing node,<br /><pre class="console"><br />Started even thread<br />  Party-1: Waiting for GREEN signal from main guy...<br />  Party-1: Counter Value=2<br />  Party-1: Counter Value=4<br />  Party-1: Counter Value=6<br />  Party-1: Counter Value=8<br />  Party-1: Counter Value=10<br />  Party-1: Counter Value=12<br />  Party-1: Counter Value=14<br />  Party-1: Counter Value=16<br />  Party-1: Counter Value=18<br />  Party-1: Counter Value=20<br />  Party-1: Counter Value=22<br />  Party-1: Counter Value=24<br />  Party-1: Counter Value=26<br />  Party-1: Counter Value=28<br />  Party-1: Counter Value=30<br />  Party-1: DONE!!<br /></pre><br /><br />You can see that the two-threads are co-ordinating across jvm boundaries.<br /><br />Apart from the thread-coordination, this app contains the data-sharing across nodes also. <br />In the tc-config, you can see that we have another root called <tt>runners</tt>. This is a <tt>Set&lt;String&gt;</tt> which just remembers which threads have been started.<br />If you run <tt>runWithTc.sh odd</tt> multiple times in multiple consoles, it won't let you start multiple odd-printing threads. It remembers this fact by just putting "odd" in the <tt>runners</tt> which gets shared across the nodes.<br /><br /><br />Hope you have a great time playing around ... and enjoy clustering your app with Terracotta :)<br /><br />P.S. Someday soon, I'm gonna really post something to change things like &lt; to &amp;lt ...<img src="http://feeds.feedburner.com/~r/abhisanoujam-blogspot/~4/usXRFL_jD2s" height="1" width="1"/>